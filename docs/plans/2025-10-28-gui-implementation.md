# Cross-Platform GUI Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add a cross-platform GUI using Wails with React/TypeScript frontend, maximizing code sharing with existing TUI, and comprehensive testing.

**Architecture:** Wails framework bridges Go backend (existing debugger logic) with React/TypeScript frontend. Shared service layer exposes debugger functionality to both TUI and GUI. Backend handles all emulator logic, frontend provides reactive UI with WebSocket-like communication via Wails runtime.

**Tech Stack:**
- Backend: Go 1.25+ with Wails v2.9+ bindings
- Frontend: React 18+ with TypeScript 5+, Vite bundler
- Testing: Go (testify), TypeScript (Vitest + React Testing Library)
- UI Components: shadcn/ui (Tailwind-based, accessible)

**Framework Justification:** React chosen over Vue/Svelte because: (1) most mature testing ecosystem (Vitest + React Testing Library), (2) largest component library ecosystem (shadcn/ui), (3) best TypeScript support, (4) senior engineers familiar with patterns, (5) Wails has first-class React templates.

---

## Phase 1: Environment Setup and Wails Installation

### Task 1.1: Install Wails CLI and verify prerequisites

**Files:**
- None (system installation)

**Step 1: Check Go version**

Run: `go version`
Expected: `go version go1.25.2 darwin/amd64` (or similar with 1.25+)

**Step 2: Install Wails CLI**

Run: `go install github.com/wailsapp/wails/v2/cmd/wails@latest`
Expected: Wails binary installed in `~/go/bin/wails`

**Step 3: Verify Wails installation**

Run: `wails doctor`
Expected: Output showing Go âœ“, NPM âœ“, Docker (optional), platform-specific dependencies âœ“

**Step 4: Verify Node.js and npm versions**

Run: `node --version && npm --version`
Expected: Node v18+ and npm v9+

If Node/npm missing, install via: `brew install node`

**Step 5: Commit**

```bash
# No files to commit yet, but verify environment ready
echo "Wails environment ready"
```

---

### Task 1.2: Create Wails project structure

**Files:**
- Create: `gui/` (new directory for GUI code)
- Create: `gui/main.go`
- Create: `gui/app.go`
- Create: `gui/frontend/` (generated by Wails)
- Modify: `.gitignore`

**Step 1: Initialize Wails project with React-TS template**

Run: `cd ~/Documents/dev/arm_emulator && wails init -n gui -t react-ts -d gui`
Expected: Creates `gui/` directory with Wails React-TypeScript template

**Step 2: Update .gitignore for GUI artifacts**

Add to `.gitignore`:
```
# GUI build artifacts
gui/build/
gui/frontend/node_modules/
gui/frontend/dist/
gui/frontend/.vite/
gui/wails.json
```

**Step 3: Verify project structure**

Run: `ls -la gui/ && ls -la gui/frontend/`
Expected: Directory structure with `main.go`, `app.go`, `frontend/` with `package.json`, `src/`, etc.

**Step 4: Test build system**

Run: `cd gui && wails build -debug`
Expected: Successful build, creates `build/bin/` directory

**Step 5: Commit**

```bash
git add gui/ .gitignore
git commit -m "$(cat <<'EOF'
feat: initialize Wails GUI project structure

- Add Wails React-TypeScript template in gui/ directory
- Configure .gitignore for GUI build artifacts
- Verify build system working

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>
EOF
)"
```

---

## Phase 2: Refactor Shared Service Layer

### Task 2.1: Create debugger service interface

**Files:**
- Create: `service/debugger_service.go`
- Create: `service/types.go`
- Test: `tests/unit/service/debugger_service_test.go`

**Step 1: Write failing test for service interface**

Create `tests/unit/service/debugger_service_test.go`:
```go
package service_test

import (
	"testing"

	"github.com/lookbusy1344/arm-emulator/parser"
	"github.com/lookbusy1344/arm-emulator/service"
	"github.com/lookbusy1344/arm-emulator/vm"
)

func TestNewDebuggerService(t *testing.T) {
	machine := vm.NewVM()
	svc := service.NewDebuggerService(machine)

	if svc == nil {
		t.Fatal("expected service instance, got nil")
	}

	if svc.GetVM() != machine {
		t.Error("service VM mismatch")
	}
}

func TestDebuggerService_LoadProgram(t *testing.T) {
	machine := vm.NewVM()
	svc := service.NewDebuggerService(machine)

	// Parse simple program
	p := parser.NewParser("_start:\nMOV R0, #42\nSWI #0", "test.s")
	program, err := p.Parse()
	if err != nil {
		t.Fatalf("parse error: %v", err)
	}

	// Load into service
	err = svc.LoadProgram(program, 0x8000)
	if err != nil {
		t.Fatalf("LoadProgram failed: %v", err)
	}

	// Verify PC set correctly
	if machine.CPU.PC != 0x8000 {
		t.Errorf("expected PC=0x8000, got 0x%08X", machine.CPU.PC)
	}
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./tests/unit/service/... -v`
Expected: FAIL with "no such file or directory" or similar

**Step 3: Create types.go with shared types**

Create `service/types.go`:
```go
package service

import "github.com/lookbusy1344/arm-emulator/vm"

// RegisterState represents a snapshot of CPU registers
type RegisterState struct {
	Registers [16]uint32
	CPSR      CPSRState
	PC        uint32
	Cycles    uint64
}

// CPSRState represents CPSR flags for serialization
type CPSRState struct {
	N bool // Negative
	Z bool // Zero
	C bool // Carry
	V bool // Overflow
}

// BreakpointInfo represents a breakpoint for UI display
type BreakpointInfo struct {
	Address uint32
	Enabled bool
}

// WatchpointInfo represents a watchpoint for UI display
type WatchpointInfo struct {
	Address uint32
	Type    string // "read", "write", "readwrite"
	Enabled bool
}

// MemoryRegion represents a contiguous memory region
type MemoryRegion struct {
	Address uint32
	Data    []byte
	Size    uint32
}

// ExecutionState represents the current state of execution
type ExecutionState string

const (
	StateIdle    ExecutionState = "idle"
	StateRunning ExecutionState = "running"
	StatePaused  ExecutionState = "paused"
	StateHalted  ExecutionState = "halted"
	StateError   ExecutionState = "error"
)

// VMStateToExecution converts vm.State to ExecutionState
func VMStateToExecution(state vm.State) ExecutionState {
	switch state {
	case vm.StateIdle:
		return StateIdle
	case vm.StateRunning:
		return StateRunning
	case vm.StatePaused:
		return StatePaused
	case vm.StateHalted:
		return StateHalted
	default:
		return StateIdle
	}
}
```

**Step 4: Create debugger_service.go with implementation**

Create `service/debugger_service.go`:
```go
package service

import (
	"fmt"
	"sync"

	"github.com/lookbusy1344/arm-emulator/debugger"
	"github.com/lookbusy1344/arm-emulator/encoder"
	"github.com/lookbusy1344/arm-emulator/parser"
	"github.com/lookbusy1344/arm-emulator/vm"
)

// DebuggerService provides a thread-safe interface to debugger functionality
// This service is shared by TUI, GUI, and CLI interfaces
type DebuggerService struct {
	mu          sync.RWMutex
	vm          *vm.VM
	debugger    *debugger.Debugger
	symbols     map[string]uint32
	sourceMap   map[uint32]string
	program     *parser.Program
	entryPoint  uint32
}

// NewDebuggerService creates a new debugger service
func NewDebuggerService(machine *vm.VM) *DebuggerService {
	return &DebuggerService{
		vm:       machine,
		debugger: debugger.NewDebugger(machine),
		symbols:  make(map[string]uint32),
		sourceMap: make(map[uint32]string),
	}
}

// GetVM returns the underlying VM (for testing)
func (s *DebuggerService) GetVM() *vm.VM {
	s.mu.RLock()
	defer s.mu.RUnlock()
	return s.vm
}

// LoadProgram loads and initializes a parsed program
func (s *DebuggerService) LoadProgram(program *parser.Program, entryPoint uint32) error {
	s.mu.Lock()
	defer s.mu.Unlock()

	s.program = program
	s.entryPoint = entryPoint

	// Extract symbols
	s.symbols = make(map[string]uint32)
	for name, symbol := range program.SymbolTable.GetAllSymbols() {
		if symbol.Type == parser.SymbolLabel {
			s.symbols[name] = symbol.Value
		}
	}

	// Build source map
	s.sourceMap = make(map[uint32]string)
	for _, inst := range program.Instructions {
		s.sourceMap[inst.Address] = inst.RawLine
	}
	for _, dir := range program.Directives {
		if dir.Name == ".word" || dir.Name == ".byte" || dir.Name == ".ascii" ||
		   dir.Name == ".asciz" || dir.Name == ".space" {
			s.sourceMap[dir.Address] = "[DATA]" + dir.RawLine
		}
	}

	// Load into debugger
	s.debugger.LoadSymbols(s.symbols)
	s.debugger.LoadSourceMap(s.sourceMap)

	// Load into VM memory (simplified version of main.go logic)
	return s.loadProgramIntoVM(program, entryPoint)
}

// loadProgramIntoVM is a simplified version of main.go's loadProgramIntoVM
func (s *DebuggerService) loadProgramIntoVM(program *parser.Program, entryPoint uint32) error {
	// Create low memory segment if needed
	if entryPoint < vm.CodeSegmentStart {
		segmentSize := uint32(vm.CodeSegmentStart)
		s.vm.Memory.AddSegment("low-memory", 0, segmentSize, vm.PermRead|vm.PermWrite|vm.PermExecute)
	}

	// Create encoder
	enc := encoder.NewEncoder(program.SymbolTable)
	enc.LiteralPoolLocs = append([]uint32(nil), program.LiteralPoolLocs...)
	enc.LiteralPoolCounts = append([]int(nil), program.LiteralPoolCounts...)

	// Build address map
	addressMap := make(map[*parser.Instruction]uint32)
	maxAddr := entryPoint
	for _, inst := range program.Instructions {
		addressMap[inst] = inst.Address
		instEnd := inst.Address + 4
		if instEnd > maxAddr {
			maxAddr = instEnd
		}
	}

	// Set literal pool start
	literalPoolStart := (maxAddr + 3) & ^uint32(3)
	enc.LiteralPoolStart = literalPoolStart

	// Encode and write instructions
	for _, inst := range program.Instructions {
		addr := addressMap[inst]
		opcode, err := enc.EncodeInstruction(inst, addr)
		if err != nil {
			return fmt.Errorf("encode error at 0x%08X: %w", addr, err)
		}
		if err := s.vm.Memory.WriteWordUnsafe(addr, opcode); err != nil {
			return fmt.Errorf("write error at 0x%08X: %w", addr, err)
		}
	}

	// Write literal pool
	for addr, value := range enc.LiteralPool {
		if err := s.vm.Memory.WriteWordUnsafe(addr, value); err != nil {
			return fmt.Errorf("literal write error at 0x%08X: %w", addr, err)
		}
	}

	// Set PC
	s.vm.CPU.PC = entryPoint
	s.vm.EntryPoint = entryPoint

	return nil
}

// GetRegisterState returns current register state (thread-safe)
func (s *DebuggerService) GetRegisterState() RegisterState {
	s.mu.RLock()
	defer s.mu.RUnlock()

	return RegisterState{
		Registers: s.vm.CPU.Registers,
		CPSR: CPSRState{
			N: s.vm.CPU.CPSR.N,
			Z: s.vm.CPU.CPSR.Z,
			C: s.vm.CPU.CPSR.C,
			V: s.vm.CPU.CPSR.V,
		},
		PC:     s.vm.CPU.PC,
		Cycles: s.vm.CPU.Cycles,
	}
}

// Step executes a single instruction
func (s *DebuggerService) Step() error {
	s.mu.Lock()
	defer s.mu.Unlock()
	return s.vm.Step()
}

// Continue runs until breakpoint or halt
func (s *DebuggerService) Continue() error {
	s.mu.Lock()
	defer s.mu.Unlock()

	s.debugger.Running = true
	s.debugger.StepMode = debugger.StepNone

	return nil
}

// Pause pauses execution
func (s *DebuggerService) Pause() {
	s.mu.Lock()
	defer s.mu.Unlock()
	s.debugger.Running = false
}

// Reset resets VM to entry point
func (s *DebuggerService) Reset() error {
	s.mu.Lock()
	defer s.mu.Unlock()

	s.vm.CPU.PC = s.entryPoint
	s.vm.State = vm.StateIdle
	s.debugger.Running = false

	return nil
}

// GetExecutionState returns current execution state
func (s *DebuggerService) GetExecutionState() ExecutionState {
	s.mu.RLock()
	defer s.mu.RUnlock()
	return VMStateToExecution(s.vm.State)
}

// AddBreakpoint adds a breakpoint at the specified address
func (s *DebuggerService) AddBreakpoint(address uint32) error {
	s.mu.Lock()
	defer s.mu.Unlock()
	return s.debugger.Breakpoints.Add(address)
}

// RemoveBreakpoint removes a breakpoint
func (s *DebuggerService) RemoveBreakpoint(address uint32) error {
	s.mu.Lock()
	defer s.mu.Unlock()
	s.debugger.Breakpoints.Remove(address)
	return nil
}

// GetBreakpoints returns all breakpoints
func (s *DebuggerService) GetBreakpoints() []BreakpointInfo {
	s.mu.RLock()
	defer s.mu.RUnlock()

	bps := s.debugger.Breakpoints.List()
	result := make([]BreakpointInfo, len(bps))
	for i, bp := range bps {
		result[i] = BreakpointInfo{
			Address: bp.Address,
			Enabled: bp.Enabled,
		}
	}
	return result
}

// GetMemory returns memory contents for a region
func (s *DebuggerService) GetMemory(address uint32, size uint32) ([]byte, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()

	data := make([]byte, size)
	for i := uint32(0); i < size; i++ {
		b, err := s.vm.Memory.ReadByte(address + i)
		if err != nil {
			return nil, err
		}
		data[i] = b
	}
	return data, nil
}

// GetSourceLine returns the source line for an address
func (s *DebuggerService) GetSourceLine(address uint32) string {
	s.mu.RLock()
	defer s.mu.RUnlock()
	return s.sourceMap[address]
}

// GetSymbols returns all symbols
func (s *DebuggerService) GetSymbols() map[string]uint32 {
	s.mu.RLock()
	defer s.mu.RUnlock()

	// Return copy to prevent external modification
	result := make(map[string]uint32, len(s.symbols))
	for k, v := range s.symbols {
		result[k] = v
	}
	return result
}
```

**Step 5: Run tests to verify they pass**

Run: `go test ./tests/unit/service/... -v`
Expected: PASS for all tests

**Step 6: Commit**

```bash
git add service/ tests/unit/service/
git commit -m "$(cat <<'EOF'
feat: create shared debugger service layer

- Add service package with DebuggerService
- Thread-safe interface for debugger operations
- Shared types for UI serialization
- Unit tests for service layer

This service layer will be shared by TUI, GUI, and CLI.

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>
EOF
)"
```

---

### Task 2.2: Add execution control to service

**Files:**
- Modify: `service/debugger_service.go`
- Modify: `service/types.go`
- Test: `tests/unit/service/execution_test.go`

**Step 1: Write failing test for execution control**

Create `tests/unit/service/execution_test.go`:
```go
package service_test

import (
	"testing"
	"time"

	"github.com/lookbusy1344/arm-emulator/parser"
	"github.com/lookbusy1344/arm-emulator/service"
	"github.com/lookbusy1344/arm-emulator/vm"
)

func TestDebuggerService_StepExecution(t *testing.T) {
	machine := vm.NewVM()
	machine.InitializeStack(0x30001000)
	svc := service.NewDebuggerService(machine)

	// Load simple program: MOV R0, #42; SWI #0
	p := parser.NewParser("_start:\nMOV R0, #42\nSWI #0", "test.s")
	program, err := p.Parse()
	if err != nil {
		t.Fatalf("parse error: %v", err)
	}

	if err := svc.LoadProgram(program, 0x8000); err != nil {
		t.Fatalf("LoadProgram failed: %v", err)
	}

	// Initial state
	state := svc.GetExecutionState()
	if state != service.StateIdle {
		t.Errorf("expected StateIdle, got %s", state)
	}

	// Execute one step
	if err := svc.Step(); err != nil {
		t.Fatalf("Step failed: %v", err)
	}

	// Check register changed
	regs := svc.GetRegisterState()
	if regs.Registers[0] != 42 {
		t.Errorf("expected R0=42, got %d", regs.Registers[0])
	}
}

func TestDebuggerService_ContinueExecution(t *testing.T) {
	machine := vm.NewVM()
	machine.InitializeStack(0x30001000)
	svc := service.NewDebuggerService(machine)

	// Load program with loop
	code := `_start:
		MOV R0, #0
	loop:
		ADD R0, R0, #1
		CMP R0, #10
		BLT loop
		SWI #0`

	p := parser.NewParser(code, "test.s")
	program, err := p.Parse()
	if err != nil {
		t.Fatalf("parse error: %v", err)
	}

	if err := svc.LoadProgram(program, 0x8000); err != nil {
		t.Fatalf("LoadProgram failed: %v", err)
	}

	// Start execution in background
	errChan := make(chan error, 1)
	go func() {
		errChan <- svc.RunUntilHalt()
	}()

	// Wait a bit for execution
	time.Sleep(10 * time.Millisecond)

	// Wait for completion
	select {
	case err := <-errChan:
		if err != nil {
			t.Fatalf("RunUntilHalt failed: %v", err)
		}
	case <-time.After(1 * time.Second):
		t.Fatal("execution timeout")
	}

	// Check final state
	regs := svc.GetRegisterState()
	if regs.Registers[0] != 10 {
		t.Errorf("expected R0=10, got %d", regs.Registers[0])
	}
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./tests/unit/service/execution_test.go -v`
Expected: FAIL with "RunUntilHalt undefined"

**Step 3: Add execution control methods to service**

Add to `service/debugger_service.go`:
```go
// RunUntilHalt runs program until halt or breakpoint
func (s *DebuggerService) RunUntilHalt() error {
	s.mu.Lock()
	s.debugger.Running = true
	s.vm.State = vm.StateRunning
	s.mu.Unlock()

	for {
		s.mu.Lock()
		if !s.debugger.Running || s.vm.State != vm.StateRunning {
			s.mu.Unlock()
			break
		}

		// Check breakpoints
		if shouldBreak, _ := s.debugger.ShouldBreak(); shouldBreak {
			s.debugger.Running = false
			s.vm.State = vm.StatePaused
			s.mu.Unlock()
			break
		}

		// Execute step
		err := s.vm.Step()
		s.mu.Unlock()

		if err != nil {
			s.mu.Lock()
			s.debugger.Running = false
			s.mu.Unlock()
			return err
		}

		s.mu.RLock()
		halted := s.vm.State == vm.StateHalted
		s.mu.RUnlock()

		if halted {
			s.mu.Lock()
			s.debugger.Running = false
			s.mu.Unlock()
			break
		}
	}

	return nil
}

// IsRunning returns whether execution is in progress
func (s *DebuggerService) IsRunning() bool {
	s.mu.RLock()
	defer s.mu.RUnlock()
	return s.debugger.Running
}

// GetExitCode returns the program exit code
func (s *DebuggerService) GetExitCode() uint32 {
	s.mu.RLock()
	defer s.mu.RUnlock()
	return s.vm.ExitCode
}
```

**Step 4: Run tests to verify they pass**

Run: `go test ./tests/unit/service/... -v`
Expected: PASS for all tests

**Step 5: Commit**

```bash
git add service/ tests/unit/service/
git commit -m "$(cat <<'EOF'
feat: add execution control to debugger service

- Add RunUntilHalt for continuous execution
- Add IsRunning and GetExitCode methods
- Thread-safe execution control
- Tests for step and continuous execution

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>
EOF
)"
```

---

## Phase 3: Wails Backend Integration

### Task 3.1: Create Wails app bindings

**Files:**
- Modify: `gui/app.go`
- Create: `gui/app_test.go`

**Step 1: Write failing test for Wails app**

Create `gui/app_test.go`:
```go
package main

import (
	"testing"

	"github.com/lookbusy1344/arm-emulator/parser"
	"github.com/lookbusy1344/arm-emulator/vm"
)

func TestApp_LoadProgram(t *testing.T) {
	app := NewApp()

	// Parse simple program
	source := "_start:\nMOV R0, #42\nSWI #0"
	err := app.LoadProgramFromSource(source, "test.s", 0x8000)
	if err != nil {
		t.Fatalf("LoadProgramFromSource failed: %v", err)
	}

	// Get registers
	regs := app.GetRegisters()
	if regs.PC != 0x8000 {
		t.Errorf("expected PC=0x8000, got 0x%08X", regs.PC)
	}
}

func TestApp_StepExecution(t *testing.T) {
	app := NewApp()

	source := "_start:\nMOV R0, #42\nSWI #0"
	if err := app.LoadProgramFromSource(source, "test.s", 0x8000); err != nil {
		t.Fatalf("LoadProgramFromSource failed: %v", err)
	}

	// Step once
	err := app.Step()
	if err != nil {
		t.Fatalf("Step failed: %v", err)
	}

	// Check R0 changed
	regs := app.GetRegisters()
	if regs.Registers[0] != 42 {
		t.Errorf("expected R0=42, got %d", regs.Registers[0])
	}
}
```

**Step 2: Run test to verify it fails**

Run: `cd gui && go test -v`
Expected: FAIL with "LoadProgramFromSource undefined"

**Step 3: Replace gui/app.go with service integration**

Replace `gui/app.go`:
```go
package main

import (
	"context"
	"fmt"

	"github.com/lookbusy1344/arm-emulator/parser"
	"github.com/lookbusy1344/arm-emulator/service"
	"github.com/lookbusy1344/arm-emulator/vm"
)

// App struct
type App struct {
	ctx     context.Context
	service *service.DebuggerService
	machine *vm.VM
}

// NewApp creates a new App application struct
func NewApp() *App {
	machine := vm.NewVM()
	machine.InitializeStack(0x30001000) // Default stack

	return &App{
		machine: machine,
		service: service.NewDebuggerService(machine),
	}
}

// startup is called when the app starts
func (a *App) startup(ctx context.Context) {
	a.ctx = ctx
}

// LoadProgramFromSource parses and loads assembly source code
func (a *App) LoadProgramFromSource(source string, filename string, entryPoint uint32) error {
	p := parser.NewParser(source, filename)
	program, err := p.Parse()
	if err != nil {
		return fmt.Errorf("parse error: %w", err)
	}

	return a.service.LoadProgram(program, entryPoint)
}

// GetRegisters returns current register state
func (a *App) GetRegisters() service.RegisterState {
	return a.service.GetRegisterState()
}

// Step executes a single instruction
func (a *App) Step() error {
	return a.service.Step()
}

// Continue runs until breakpoint or halt
func (a *App) Continue() error {
	return a.service.RunUntilHalt()
}

// Pause pauses execution
func (a *App) Pause() {
	a.service.Pause()
}

// Reset resets VM to initial state
func (a *App) Reset() error {
	return a.service.Reset()
}

// AddBreakpoint adds a breakpoint at address
func (a *App) AddBreakpoint(address uint32) error {
	return a.service.AddBreakpoint(address)
}

// RemoveBreakpoint removes a breakpoint
func (a *App) RemoveBreakpoint(address uint32) error {
	return a.service.RemoveBreakpoint(address)
}

// GetBreakpoints returns all breakpoints
func (a *App) GetBreakpoints() []service.BreakpointInfo {
	return a.service.GetBreakpoints()
}

// GetMemory returns memory contents
func (a *App) GetMemory(address uint32, size uint32) ([]byte, error) {
	return a.service.GetMemory(address, size)
}

// GetSourceLine returns source for address
func (a *App) GetSourceLine(address uint32) string {
	return a.service.GetSourceLine(address)
}

// GetSymbols returns all symbols
func (a *App) GetSymbols() map[string]uint32 {
	return a.service.GetSymbols()
}

// GetExecutionState returns current state
func (a *App) GetExecutionState() string {
	return string(a.service.GetExecutionState())
}

// IsRunning returns whether execution is active
func (a *App) IsRunning() bool {
	return a.service.IsRunning()
}
```

**Step 4: Run tests to verify they pass**

Run: `cd gui && go test -v`
Expected: PASS for all tests

**Step 5: Update main.go to bind methods**

Modify `gui/main.go` to bind App methods:
```go
package main

import (
	"embed"
	"log"

	"github.com/wailsapp/wails/v2"
	"github.com/wailsapp/wails/v2/pkg/options"
	"github.com/wailsapp/wails/v2/pkg/options/assetserver"
)

//go:embed all:frontend/dist
var assets embed.FS

func main() {
	// Create application
	app := NewApp()

	// Create application with options
	err := wails.Run(&options.App{
		Title:  "ARM Emulator",
		Width:  1280,
		Height: 800,
		AssetServer: &assetserver.Options{
			Assets: assets,
		},
		BackgroundColour: &options.RGBA{R: 27, G: 38, B: 54, A: 1},
		OnStartup:        app.startup,
		Bind: []interface{}{
			app,
		},
	})

	if err != nil {
		log.Fatal(err)
	}
}
```

**Step 6: Commit**

```bash
git add gui/
git commit -m "$(cat <<'EOF'
feat: integrate service layer with Wails backend

- Replace template app.go with service integration
- Bind all debugger methods for frontend access
- Add unit tests for Wails app bindings
- Configure main.go with proper options

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>
EOF
)"
```

---

## Phase 4: Frontend Setup with React/TypeScript

### Task 4.1: Configure frontend dependencies and tooling

**Files:**
- Modify: `gui/frontend/package.json`
- Create: `gui/frontend/tsconfig.json` (if not exists)
- Create: `gui/frontend/vite.config.ts`
- Modify: `gui/frontend/.eslintrc.cjs` (if exists)

**Step 1: Update package.json with required dependencies**

Modify `gui/frontend/package.json`, add/update dependencies:
```json
{
  "dependencies": {
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "@radix-ui/react-tabs": "^1.1.1",
    "@radix-ui/react-dropdown-menu": "^2.1.2",
    "clsx": "^2.1.1",
    "tailwind-merge": "^2.5.4"
  },
  "devDependencies": {
    "@types/react": "^18.3.12",
    "@types/react-dom": "^18.3.1",
    "@vitejs/plugin-react": "^4.3.3",
    "typescript": "^5.6.3",
    "vite": "^5.4.11",
    "vitest": "^2.1.5",
    "@testing-library/react": "^16.0.1",
    "@testing-library/jest-dom": "^6.6.3",
    "@testing-library/user-event": "^14.5.2",
    "jsdom": "^25.0.1",
    "autoprefixer": "^10.4.20",
    "postcss": "^8.4.49",
    "tailwindcss": "^3.4.15"
  }
}
```

**Step 2: Install dependencies**

Run: `cd gui/frontend && npm install`
Expected: All dependencies installed successfully

**Step 3: Create Vitest config**

Create `gui/frontend/vitest.config.ts`:
```typescript
import { defineConfig } from 'vitest/config'
import react from '@vitejs/plugin-react'
import path from 'path'

export default defineConfig({
  plugins: [react()],
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: ['./src/test/setup.ts'],
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      exclude: [
        'node_modules/',
        'src/test/',
        '**/*.test.{ts,tsx}',
        '**/*.spec.{ts,tsx}',
      ],
    },
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
})
```

**Step 4: Create test setup file**

Create `gui/frontend/src/test/setup.ts`:
```typescript
import '@testing-library/jest-dom'
import { expect, afterEach } from 'vitest'
import { cleanup } from '@testing-library/react'
import * as matchers from '@testing-library/jest-dom/matchers'

expect.extend(matchers)

// Cleanup after each test
afterEach(() => {
  cleanup()
})
```

**Step 5: Configure Tailwind CSS**

Create `gui/frontend/tailwind.config.js`:
```javascript
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      fontFamily: {
        mono: ['JetBrains Mono', 'Menlo', 'Monaco', 'Courier New', 'monospace'],
      },
    },
  },
  plugins: [],
}
```

Create `gui/frontend/postcss.config.js`:
```javascript
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
```

**Step 6: Commit**

```bash
git add gui/frontend/
git commit -m "$(cat <<'EOF'
feat: configure frontend tooling and dependencies

- Add React 18, TypeScript 5, Vitest testing
- Configure Tailwind CSS for styling
- Add React Testing Library for component tests
- Set up test environment and coverage

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>
EOF
)"
```

---

### Task 4.2: Create TypeScript bindings for backend

**Files:**
- Create: `gui/frontend/src/services/wails.ts`
- Create: `gui/frontend/src/types/emulator.ts`
- Test: `gui/frontend/src/services/wails.test.ts`

**Step 1: Write failing test for Wails bindings**

Create `gui/frontend/src/services/wails.test.ts`:
```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { EmulatorAPI } from './wails'

// Mock window.go
const mockGo = {
  main: {
    App: {
      LoadProgramFromSource: vi.fn(),
      GetRegisters: vi.fn(),
      Step: vi.fn(),
      Continue: vi.fn(),
    },
  },
}

declare global {
  interface Window {
    go: typeof mockGo
  }
}

beforeEach(() => {
  window.go = mockGo as any
  vi.clearAllMocks()
})

describe('EmulatorAPI', () => {
  it('should load program from source', async () => {
    mockGo.main.App.LoadProgramFromSource.mockResolvedValue(null)

    await EmulatorAPI.loadProgram('MOV R0, #42', 'test.s', 0x8000)

    expect(mockGo.main.App.LoadProgramFromSource).toHaveBeenCalledWith(
      'MOV R0, #42',
      'test.s',
      0x8000
    )
  })

  it('should get registers', async () => {
    const mockRegs = {
      Registers: new Array(16).fill(0),
      CPSR: { N: false, Z: false, C: false, V: false },
      PC: 0x8000,
      Cycles: 0,
    }
    mockGo.main.App.GetRegisters.mockResolvedValue(mockRegs)

    const regs = await EmulatorAPI.getRegisters()

    expect(regs).toEqual(mockRegs)
    expect(mockGo.main.App.GetRegisters).toHaveBeenCalled()
  })

  it('should step execution', async () => {
    mockGo.main.App.Step.mockResolvedValue(null)

    await EmulatorAPI.step()

    expect(mockGo.main.App.Step).toHaveBeenCalled()
  })
})
```

**Step 2: Run test to verify it fails**

Run: `cd gui/frontend && npm test`
Expected: FAIL with "Cannot find module './wails'"

**Step 3: Create TypeScript types**

Create `gui/frontend/src/types/emulator.ts`:
```typescript
export interface RegisterState {
  Registers: number[]  // [16]uint32 from Go
  CPSR: CPSRState
  PC: number           // uint32
  Cycles: number       // uint64 (may lose precision for very large values)
}

export interface CPSRState {
  N: boolean  // Negative
  Z: boolean  // Zero
  C: boolean  // Carry
  V: boolean  // Overflow
}

export interface BreakpointInfo {
  Address: number   // uint32
  Enabled: boolean
}

export interface WatchpointInfo {
  Address: number   // uint32
  Type: string      // "read" | "write" | "readwrite"
  Enabled: boolean
}

export type ExecutionState = 'idle' | 'running' | 'paused' | 'halted' | 'error'

export interface SymbolTable {
  [name: string]: number  // uint32
}
```

**Step 4: Create Wails API wrapper**

Create `gui/frontend/src/services/wails.ts`:
```typescript
import type {
  RegisterState,
  BreakpointInfo,
  ExecutionState,
  SymbolTable,
} from '../types/emulator'

// Wails runtime bindings
// These are injected by Wails at runtime via window.go
declare global {
  interface Window {
    go: {
      main: {
        App: {
          LoadProgramFromSource: (source: string, filename: string, entryPoint: number) => Promise<string | null>
          GetRegisters: () => Promise<RegisterState>
          Step: () => Promise<string | null>
          Continue: () => Promise<string | null>
          Pause: () => Promise<void>
          Reset: () => Promise<string | null>
          AddBreakpoint: (address: number) => Promise<string | null>
          RemoveBreakpoint: (address: number) => Promise<string | null>
          GetBreakpoints: () => Promise<BreakpointInfo[]>
          GetMemory: (address: number, size: number) => Promise<number[]>
          GetSourceLine: (address: number) => Promise<string>
          GetSymbols: () => Promise<SymbolTable>
          GetExecutionState: () => Promise<string>
          IsRunning: () => Promise<boolean>
        }
      }
    }
  }
}

/**
 * EmulatorAPI provides typed wrapper around Wails backend methods
 * All methods return promises that resolve on success or reject with error message
 */
export const EmulatorAPI = {
  /**
   * Load and parse assembly source code
   */
  async loadProgram(source: string, filename: string, entryPoint: number): Promise<void> {
    const err = await window.go.main.App.LoadProgramFromSource(source, filename, entryPoint)
    if (err) {
      throw new Error(err)
    }
  },

  /**
   * Get current register state
   */
  async getRegisters(): Promise<RegisterState> {
    return window.go.main.App.GetRegisters()
  },

  /**
   * Execute single instruction
   */
  async step(): Promise<void> {
    const err = await window.go.main.App.Step()
    if (err) {
      throw new Error(err)
    }
  },

  /**
   * Continue execution until breakpoint or halt
   */
  async continue(): Promise<void> {
    const err = await window.go.main.App.Continue()
    if (err) {
      throw new Error(err)
    }
  },

  /**
   * Pause execution
   */
  async pause(): Promise<void> {
    await window.go.main.App.Pause()
  },

  /**
   * Reset VM to initial state
   */
  async reset(): Promise<void> {
    const err = await window.go.main.App.Reset()
    if (err) {
      throw new Error(err)
    }
  },

  /**
   * Add breakpoint at address
   */
  async addBreakpoint(address: number): Promise<void> {
    const err = await window.go.main.App.AddBreakpoint(address)
    if (err) {
      throw new Error(err)
    }
  },

  /**
   * Remove breakpoint
   */
  async removeBreakpoint(address: number): Promise<void> {
    const err = await window.go.main.App.RemoveBreakpoint(address)
    if (err) {
      throw new Error(err)
    }
  },

  /**
   * Get all breakpoints
   */
  async getBreakpoints(): Promise<BreakpointInfo[]> {
    return window.go.main.App.GetBreakpoints()
  },

  /**
   * Read memory region
   */
  async getMemory(address: number, size: number): Promise<Uint8Array> {
    const data = await window.go.main.App.GetMemory(address, size)
    return new Uint8Array(data)
  },

  /**
   * Get source line for address
   */
  async getSourceLine(address: number): Promise<string> {
    return window.go.main.App.GetSourceLine(address)
  },

  /**
   * Get all symbols
   */
  async getSymbols(): Promise<SymbolTable> {
    return window.go.main.App.GetSymbols()
  },

  /**
   * Get current execution state
   */
  async getExecutionState(): Promise<ExecutionState> {
    const state = await window.go.main.App.GetExecutionState()
    return state as ExecutionState
  },

  /**
   * Check if execution is active
   */
  async isRunning(): Promise<boolean> {
    return window.go.main.App.IsRunning()
  },
}
```

**Step 5: Run tests to verify they pass**

Run: `cd gui/frontend && npm test`
Expected: PASS for all tests

**Step 6: Commit**

```bash
git add gui/frontend/
git commit -m "$(cat <<'EOF'
feat: create TypeScript bindings for Wails backend

- Add typed EmulatorAPI wrapper for all backend methods
- Define TypeScript types matching Go structs
- Unit tests for API wrapper
- Type-safe promise-based interface

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>
EOF
)"
```

---

## Phase 5: Core React Components

### Task 5.1: Create RegisterView component

**Files:**
- Create: `gui/frontend/src/components/RegisterView.tsx`
- Create: `gui/frontend/src/components/RegisterView.test.tsx`
- Create: `gui/frontend/src/components/RegisterView.css`

**Step 1: Write failing test for RegisterView**

Create `gui/frontend/src/components/RegisterView.test.tsx`:
```typescript
import { describe, it, expect } from 'vitest'
import { render, screen } from '@testing-library/react'
import { RegisterView } from './RegisterView'
import type { RegisterState } from '../types/emulator'

describe('RegisterView', () => {
  const mockRegisters: RegisterState = {
    Registers: [42, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    CPSR: { N: true, Z: false, C: false, V: false },
    PC: 0x8000,
    Cycles: 123,
  }

  it('should render all registers', () => {
    render(<RegisterView registers={mockRegisters} />)

    // Check R0-R15 labels exist
    for (let i = 0; i < 16; i++) {
      expect(screen.getByText(`R${i}`)).toBeInTheDocument()
    }
  })

  it('should display register values in hex', () => {
    render(<RegisterView registers={mockRegisters} />)

    // R0 should show 0x0000002A (42 in hex)
    expect(screen.getByText(/0x0000002A/i)).toBeInTheDocument()
  })

  it('should display CPSR flags', () => {
    render(<RegisterView registers={mockRegisters} />)

    expect(screen.getByText(/N/)).toBeInTheDocument()
    expect(screen.getByText(/Z/)).toBeInTheDocument()
    expect(screen.getByText(/C/)).toBeInTheDocument()
    expect(screen.getByText(/V/)).toBeInTheDocument()
  })

  it('should highlight changed registers', () => {
    const changedRegs = new Set([0, 15])
    const { container } = render(
      <RegisterView registers={mockRegisters} changedRegisters={changedRegs} />
    )

    // R0 and PC (R15) should have highlight class
    const highlighted = container.querySelectorAll('.register-changed')
    expect(highlighted).toHaveLength(2)
  })

  it('should display PC value', () => {
    render(<RegisterView registers={mockRegisters} />)

    expect(screen.getByText(/0x00008000/i)).toBeInTheDocument()
  })

  it('should display cycle count', () => {
    render(<RegisterView registers={mockRegisters} />)

    expect(screen.getByText(/123/)).toBeInTheDocument()
  })
})
```

**Step 2: Run test to verify it fails**

Run: `cd gui/frontend && npm test -- RegisterView`
Expected: FAIL with "Cannot find module './RegisterView'"

**Step 3: Implement RegisterView component**

Create `gui/frontend/src/components/RegisterView.tsx`:
```typescript
import React from 'react'
import type { RegisterState } from '../types/emulator'
import './RegisterView.css'

interface RegisterViewProps {
  registers: RegisterState
  changedRegisters?: Set<number>
}

const formatHex32 = (value: number): string => {
  return `0x${value.toString(16).toUpperCase().padStart(8, '0')}`
}

export const RegisterView: React.FC<RegisterViewProps> = ({
  registers,
  changedRegisters = new Set(),
}) => {
  const { Registers, CPSR, PC, Cycles } = registers

  return (
    <div className="register-view">
      <h3 className="register-view-title">Registers</h3>

      {/* General Purpose Registers */}
      <div className="register-grid">
        {Registers.map((value, index) => (
          <div
            key={index}
            className={`register-row ${changedRegisters.has(index) ? 'register-changed' : ''}`}
          >
            <span className="register-name">R{index}</span>
            <span className="register-value">{formatHex32(value)}</span>
            <span className="register-decimal">({value})</span>
          </div>
        ))}
      </div>

      {/* CPSR Flags */}
      <div className="cpsr-section">
        <h4 className="cpsr-title">CPSR Flags</h4>
        <div className="cpsr-flags">
          <span className={`flag ${CPSR.N ? 'flag-set' : 'flag-clear'}`}>
            N: {CPSR.N ? '1' : '0'}
          </span>
          <span className={`flag ${CPSR.Z ? 'flag-set' : 'flag-clear'}`}>
            Z: {CPSR.Z ? '1' : '0'}
          </span>
          <span className={`flag ${CPSR.C ? 'flag-set' : 'flag-clear'}`}>
            C: {CPSR.C ? '1' : '0'}
          </span>
          <span className={`flag ${CPSR.V ? 'flag-set' : 'flag-clear'}`}>
            V: {CPSR.V ? '1' : '0'}
          </span>
        </div>
      </div>

      {/* Special Registers */}
      <div className="special-registers">
        <div className="register-row">
          <span className="register-name">PC</span>
          <span className="register-value">{formatHex32(PC)}</span>
        </div>
        <div className="register-row">
          <span className="register-name">Cycles</span>
          <span className="register-value">{Cycles}</span>
        </div>
      </div>
    </div>
  )
}
```

**Step 4: Create RegisterView styles**

Create `gui/frontend/src/components/RegisterView.css`:
```css
.register-view {
  font-family: 'JetBrains Mono', monospace;
  font-size: 13px;
  padding: 12px;
  background: #1e1e1e;
  color: #d4d4d4;
  height: 100%;
  overflow-y: auto;
}

.register-view-title {
  font-size: 14px;
  font-weight: 600;
  margin: 0 0 12px 0;
  color: #569cd6;
}

.register-grid {
  display: flex;
  flex-direction: column;
  gap: 4px;
  margin-bottom: 16px;
}

.register-row {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 4px 8px;
  border-radius: 3px;
  transition: background-color 0.2s;
}

.register-row:hover {
  background: #2d2d2d;
}

.register-changed {
  background: #3a2d1a !important;
  animation: highlight-pulse 0.5s ease-out;
}

@keyframes highlight-pulse {
  0% { background: #6b5a2d; }
  100% { background: #3a2d1a; }
}

.register-name {
  width: 32px;
  font-weight: 600;
  color: #9cdcfe;
}

.register-value {
  font-weight: 500;
  color: #b5cea8;
  flex: 1;
}

.register-decimal {
  color: #808080;
  font-size: 11px;
}

.cpsr-section {
  margin-bottom: 16px;
  padding-top: 12px;
  border-top: 1px solid #3e3e3e;
}

.cpsr-title {
  font-size: 13px;
  font-weight: 600;
  margin: 0 0 8px 0;
  color: #569cd6;
}

.cpsr-flags {
  display: flex;
  gap: 12px;
}

.flag {
  padding: 4px 8px;
  border-radius: 3px;
  font-weight: 600;
}

.flag-set {
  background: #1e4d1e;
  color: #4ec94e;
}

.flag-clear {
  background: #2d2d2d;
  color: #808080;
}

.special-registers {
  padding-top: 12px;
  border-top: 1px solid #3e3e3e;
}
```

**Step 5: Run tests to verify they pass**

Run: `cd gui/frontend && npm test -- RegisterView`
Expected: PASS for all tests

**Step 6: Commit**

```bash
git add gui/frontend/src/components/
git commit -m "$(cat <<'EOF'
feat: create RegisterView component

- Display all 16 general-purpose registers
- Show CPSR flags with visual indicators
- Highlight changed registers with animation
- Show PC and cycle count
- Fully tested with React Testing Library

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>
EOF
)"
```

---

### Task 5.2: Create MemoryView component

**Files:**
- Create: `gui/frontend/src/components/MemoryView.tsx`
- Create: `gui/frontend/src/components/MemoryView.test.tsx`
- Create: `gui/frontend/src/components/MemoryView.css`

**Step 1: Write failing test for MemoryView**

Create `gui/frontend/src/components/MemoryView.test.tsx`:
```typescript
import { describe, it, expect } from 'vitest'
import { render, screen } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { MemoryView } from './MemoryView'

describe('MemoryView', () => {
  const mockMemory = new Uint8Array([
    0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x57, 0x6f,
    0x72, 0x6c, 0x64, 0x21, 0x00, 0x00, 0x00, 0x00,
  ])

  it('should render memory dump in hex', () => {
    render(
      <MemoryView
        memory={mockMemory}
        baseAddress={0x8000}
        onAddressChange={() => {}}
      />
    )

    // Should show hex values
    expect(screen.getByText(/48/)).toBeInTheDocument()
    expect(screen.getByText(/65/)).toBeInTheDocument()
  })

  it('should display ASCII representation', () => {
    render(
      <MemoryView
        memory={mockMemory}
        baseAddress={0x8000}
        onAddressChange={() => {}}
      />
    )

    // Should show "Hello World!"
    expect(screen.getByText(/Hello World/)).toBeInTheDocument()
  })

  it('should show base address', () => {
    render(
      <MemoryView
        memory={mockMemory}
        baseAddress={0x8000}
        onAddressChange={() => {}}
      />
    )

    expect(screen.getByText(/0x00008000/i)).toBeInTheDocument()
  })

  it('should call onAddressChange when address input changes', async () => {
    const user = userEvent.setup()
    let newAddress = 0

    render(
      <MemoryView
        memory={mockMemory}
        baseAddress={0x8000}
        onAddressChange={(addr) => { newAddress = addr }}
      />
    )

    const input = screen.getByPlaceholderText(/address/i)
    await user.clear(input)
    await user.type(input, '0x9000')
    await user.keyboard('{Enter}')

    expect(newAddress).toBe(0x9000)
  })

  it('should format addresses in rows', () => {
    render(
      <MemoryView
        memory={mockMemory}
        baseAddress={0x8000}
        onAddressChange={() => {}}
      />
    )

    // First row should start with base address
    expect(screen.getByText(/0x00008000/)).toBeInTheDocument()
    // Second row should be +0x10 (16 bytes per row)
    expect(screen.getByText(/0x00008010/)).toBeInTheDocument()
  })
})
```

**Step 2: Run test to verify it fails**

Run: `cd gui/frontend && npm test -- MemoryView`
Expected: FAIL with "Cannot find module './MemoryView'"

**Step 3: Implement MemoryView component**

Create `gui/frontend/src/components/MemoryView.tsx`:
```typescript
import React, { useState, useCallback } from 'react'
import './MemoryView.css'

interface MemoryViewProps {
  memory: Uint8Array
  baseAddress: number
  onAddressChange: (address: number) => void
  highlightAddresses?: Set<number>
}

const BYTES_PER_ROW = 16

const formatHex8 = (value: number): string => {
  return value.toString(16).toUpperCase().padStart(2, '0')
}

const formatAddress = (address: number): string => {
  return `0x${address.toString(16).toUpperCase().padStart(8, '0')}`
}

const toASCII = (byte: number): string => {
  if (byte >= 32 && byte <= 126) {
    return String.fromCharCode(byte)
  }
  return '.'
}

export const MemoryView: React.FC<MemoryViewProps> = ({
  memory,
  baseAddress,
  onAddressChange,
  highlightAddresses = new Set(),
}) => {
  const [addressInput, setAddressInput] = useState(formatAddress(baseAddress))

  const handleAddressSubmit = useCallback((e: React.FormEvent) => {
    e.preventDefault()

    let addr: number
    const input = addressInput.trim()

    if (input.startsWith('0x') || input.startsWith('0X')) {
      addr = parseInt(input.substring(2), 16)
    } else {
      addr = parseInt(input, 10)
    }

    if (!isNaN(addr)) {
      onAddressChange(addr)
    }
  }, [addressInput, onAddressChange])

  // Split memory into rows
  const rows: Uint8Array[] = []
  for (let i = 0; i < memory.length; i += BYTES_PER_ROW) {
    rows.push(memory.slice(i, i + BYTES_PER_ROW))
  }

  return (
    <div className="memory-view">
      <div className="memory-view-header">
        <h3 className="memory-view-title">Memory</h3>
        <form onSubmit={handleAddressSubmit} className="address-input-form">
          <input
            type="text"
            className="address-input"
            value={addressInput}
            onChange={(e) => setAddressInput(e.target.value)}
            placeholder="Address (0xXXXX)"
          />
          <button type="submit" className="address-go-button">Go</button>
        </form>
      </div>

      <div className="memory-dump">
        {rows.map((row, rowIndex) => {
          const rowAddress = baseAddress + rowIndex * BYTES_PER_ROW

          return (
            <div key={rowIndex} className="memory-row">
              <span className="memory-address">{formatAddress(rowAddress)}</span>

              <div className="memory-hex">
                {Array.from(row).map((byte, byteIndex) => {
                  const byteAddr = rowAddress + byteIndex
                  const isHighlighted = highlightAddresses.has(byteAddr)

                  return (
                    <span
                      key={byteIndex}
                      className={`memory-byte ${isHighlighted ? 'memory-byte-highlight' : ''}`}
                    >
                      {formatHex8(byte)}
                    </span>
                  )
                })}
              </div>

              <span className="memory-ascii">
                {Array.from(row).map((byte) => toASCII(byte)).join('')}
              </span>
            </div>
          )
        })}
      </div>
    </div>
  )
}
```

**Step 4: Create MemoryView styles**

Create `gui/frontend/src/components/MemoryView.css`:
```css
.memory-view {
  font-family: 'JetBrains Mono', monospace;
  font-size: 13px;
  padding: 12px;
  background: #1e1e1e;
  color: #d4d4d4;
  height: 100%;
  display: flex;
  flex-direction: column;
}

.memory-view-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
}

.memory-view-title {
  font-size: 14px;
  font-weight: 600;
  margin: 0;
  color: #569cd6;
}

.address-input-form {
  display: flex;
  gap: 8px;
}

.address-input {
  width: 120px;
  padding: 4px 8px;
  background: #2d2d2d;
  border: 1px solid #3e3e3e;
  border-radius: 3px;
  color: #d4d4d4;
  font-family: inherit;
  font-size: 12px;
}

.address-input:focus {
  outline: none;
  border-color: #569cd6;
}

.address-go-button {
  padding: 4px 12px;
  background: #0e639c;
  border: none;
  border-radius: 3px;
  color: #ffffff;
  font-size: 12px;
  cursor: pointer;
  font-weight: 500;
}

.address-go-button:hover {
  background: #1177bb;
}

.memory-dump {
  flex: 1;
  overflow-y: auto;
  font-size: 12px;
}

.memory-row {
  display: flex;
  align-items: center;
  gap: 16px;
  padding: 2px 0;
  line-height: 1.5;
}

.memory-row:hover {
  background: #2d2d2d;
}

.memory-address {
  color: #808080;
  width: 90px;
  flex-shrink: 0;
}

.memory-hex {
  display: flex;
  gap: 4px;
  flex: 1;
}

.memory-byte {
  color: #b5cea8;
}

.memory-byte-highlight {
  background: #3a2d1a;
  color: #dcdcaa;
  font-weight: 600;
  padding: 0 2px;
  border-radius: 2px;
}

.memory-ascii {
  color: #ce9178;
  width: 140px;
  flex-shrink: 0;
  letter-spacing: 0.05em;
}
```

**Step 5: Run tests to verify they pass**

Run: `cd gui/frontend && npm test -- MemoryView`
Expected: PASS for all tests

**Step 6: Commit**

```bash
git add gui/frontend/src/components/
git commit -m "$(cat <<'EOF'
feat: create MemoryView component

- Hex dump display with 16 bytes per row
- ASCII representation of memory
- Address input for navigation
- Highlight modified bytes
- Fully tested component

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>
EOF
)"
```

---

## Phase 6: Main Application Assembly

### Task 6.1: Create main App component

**Files:**
- Modify: `gui/frontend/src/App.tsx`
- Create: `gui/frontend/src/App.css`
- Create: `gui/frontend/src/hooks/useEmulator.ts`

**Step 1: Create useEmulator hook for state management**

Create `gui/frontend/src/hooks/useEmulator.ts`:
```typescript
import { useState, useCallback, useEffect } from 'react'
import { EmulatorAPI } from '../services/wails'
import type { RegisterState, ExecutionState, BreakpointInfo } from '../types/emulator'

export const useEmulator = () => {
  const [registers, setRegisters] = useState<RegisterState | null>(null)
  const [executionState, setExecutionState] = useState<ExecutionState>('idle')
  const [breakpoints, setBreakpoints] = useState<BreakpointInfo[]>([])
  const [memory, setMemory] = useState<Uint8Array>(new Uint8Array(256))
  const [memoryAddress, setMemoryAddress] = useState(0x8000)
  const [error, setError] = useState<string | null>(null)

  // Load program from source
  const loadProgram = useCallback(async (source: string, filename: string, entryPoint: number) => {
    try {
      await EmulatorAPI.loadProgram(source, filename, entryPoint)
      await refreshState()
      setError(null)
    } catch (err) {
      setError(err instanceof Error ? err.message : String(err))
    }
  }, [])

  // Step single instruction
  const step = useCallback(async () => {
    try {
      await EmulatorAPI.step()
      await refreshState()
      setError(null)
    } catch (err) {
      setError(err instanceof Error ? err.message : String(err))
    }
  }, [])

  // Continue execution
  const continueExecution = useCallback(async () => {
    try {
      setExecutionState('running')
      await EmulatorAPI.continue()
      await refreshState()
      setError(null)
    } catch (err) {
      setError(err instanceof Error ? err.message : String(err))
    }
  }, [])

  // Pause execution
  const pause = useCallback(async () => {
    try {
      await EmulatorAPI.pause()
      await refreshState()
      setError(null)
    } catch (err) {
      setError(err instanceof Error ? err.message : String(err))
    }
  }, [])

  // Reset VM
  const reset = useCallback(async () => {
    try {
      await EmulatorAPI.reset()
      await refreshState()
      setError(null)
    } catch (err) {
      setError(err instanceof Error ? err.message : String(err))
    }
  }, [])

  // Add breakpoint
  const addBreakpoint = useCallback(async (address: number) => {
    try {
      await EmulatorAPI.addBreakpoint(address)
      const bps = await EmulatorAPI.getBreakpoints()
      setBreakpoints(bps)
      setError(null)
    } catch (err) {
      setError(err instanceof Error ? err.message : String(err))
    }
  }, [])

  // Remove breakpoint
  const removeBreakpoint = useCallback(async (address: number) => {
    try {
      await EmulatorAPI.removeBreakpoint(address)
      const bps = await EmulatorAPI.getBreakpoints()
      setBreakpoints(bps)
      setError(null)
    } catch (err) {
      setError(err instanceof Error ? err.message : String(err))
    }
  }, [])

  // Change memory view address
  const changeMemoryAddress = useCallback(async (address: number) => {
    setMemoryAddress(address)
    try {
      const mem = await EmulatorAPI.getMemory(address, 256)
      setMemory(mem)
      setError(null)
    } catch (err) {
      setError(err instanceof Error ? err.message : String(err))
    }
  }, [])

  // Refresh all state from backend
  const refreshState = useCallback(async () => {
    try {
      const [regs, state, bps, mem] = await Promise.all([
        EmulatorAPI.getRegisters(),
        EmulatorAPI.getExecutionState(),
        EmulatorAPI.getBreakpoints(),
        EmulatorAPI.getMemory(memoryAddress, 256),
      ])

      setRegisters(regs)
      setExecutionState(state)
      setBreakpoints(bps)
      setMemory(mem)
    } catch (err) {
      setError(err instanceof Error ? err.message : String(err))
    }
  }, [memoryAddress])

  // Initial load
  useEffect(() => {
    refreshState()
  }, [])

  return {
    registers,
    executionState,
    breakpoints,
    memory,
    memoryAddress,
    error,
    loadProgram,
    step,
    continue: continueExecution,
    pause,
    reset,
    addBreakpoint,
    removeBreakpoint,
    changeMemoryAddress,
    refreshState,
  }
}
```

**Step 2: Replace App.tsx with main application**

Replace `gui/frontend/src/App.tsx`:
```typescript
import React, { useState } from 'react'
import { RegisterView } from './components/RegisterView'
import { MemoryView } from './components/MemoryView'
import { useEmulator } from './hooks/useEmulator'
import './App.css'

function App() {
  const {
    registers,
    executionState,
    memory,
    memoryAddress,
    error,
    loadProgram,
    step,
    continue: continueExecution,
    pause,
    reset,
    changeMemoryAddress,
  } = useEmulator()

  const [sourceCode, setSourceCode] = useState(`; ARM Assembly Example
_start:
    MOV R0, #42
    MOV R1, #10
    ADD R2, R0, R1
    SWI #0
`)

  const handleLoadProgram = () => {
    loadProgram(sourceCode, 'program.s', 0x8000)
  }

  return (
    <div className="app">
      <header className="app-header">
        <h1 className="app-title">ARM Emulator</h1>
        <div className="app-controls">
          <button onClick={handleLoadProgram} className="btn btn-primary">
            Load
          </button>
          <button onClick={step} className="btn" disabled={executionState === 'running'}>
            Step
          </button>
          <button onClick={continueExecution} className="btn" disabled={executionState === 'running'}>
            Run
          </button>
          <button onClick={pause} className="btn" disabled={executionState !== 'running'}>
            Pause
          </button>
          <button onClick={reset} className="btn">
            Reset
          </button>
          <span className={`status status-${executionState}`}>
            {executionState.toUpperCase()}
          </span>
        </div>
      </header>

      {error && (
        <div className="error-banner">
          <strong>Error:</strong> {error}
        </div>
      )}

      <div className="app-layout">
        <div className="app-editor">
          <textarea
            className="code-editor"
            value={sourceCode}
            onChange={(e) => setSourceCode(e.target.value)}
            spellCheck={false}
          />
        </div>

        <div className="app-panels">
          <div className="panel">
            {registers && <RegisterView registers={registers} />}
          </div>

          <div className="panel">
            <MemoryView
              memory={memory}
              baseAddress={memoryAddress}
              onAddressChange={changeMemoryAddress}
            />
          </div>
        </div>
      </div>
    </div>
  )
}

export default App
```

**Step 3: Create App styles**

Create `gui/frontend/src/App.css`:
```css
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

.app {
  display: flex;
  flex-direction: column;
  height: 100vh;
  background: #1e1e1e;
  color: #d4d4d4;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
}

.app-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px 20px;
  background: #2d2d2d;
  border-bottom: 1px solid #3e3e3e;
}

.app-title {
  font-size: 18px;
  font-weight: 600;
  color: #569cd6;
  margin: 0;
}

.app-controls {
  display: flex;
  gap: 8px;
  align-items: center;
}

.btn {
  padding: 6px 16px;
  background: #3e3e3e;
  border: 1px solid #505050;
  border-radius: 4px;
  color: #d4d4d4;
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
}

.btn:hover:not(:disabled) {
  background: #505050;
  border-color: #6a6a6a;
}

.btn:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.btn-primary {
  background: #0e639c;
  border-color: #0e639c;
  color: #ffffff;
}

.btn-primary:hover:not(:disabled) {
  background: #1177bb;
  border-color: #1177bb;
}

.status {
  padding: 6px 12px;
  border-radius: 4px;
  font-size: 11px;
  font-weight: 600;
  letter-spacing: 0.5px;
}

.status-idle {
  background: #2d2d2d;
  color: #808080;
}

.status-running {
  background: #1e4d1e;
  color: #4ec94e;
}

.status-paused {
  background: #4d3b1e;
  color: #dcdcaa;
}

.status-halted {
  background: #4d1e1e;
  color: #f48771;
}

.error-banner {
  padding: 12px 20px;
  background: #5a1d1d;
  border-bottom: 1px solid #8b3434;
  color: #f48771;
  font-size: 13px;
}

.error-banner strong {
  font-weight: 600;
}

.app-layout {
  display: flex;
  flex: 1;
  overflow: hidden;
}

.app-editor {
  flex: 1;
  display: flex;
  flex-direction: column;
  border-right: 1px solid #3e3e3e;
}

.code-editor {
  flex: 1;
  padding: 16px;
  background: #1e1e1e;
  color: #d4d4d4;
  border: none;
  font-family: 'JetBrains Mono', monospace;
  font-size: 14px;
  line-height: 1.6;
  resize: none;
  outline: none;
}

.app-panels {
  width: 400px;
  display: flex;
  flex-direction: column;
}

.panel {
  flex: 1;
  border-bottom: 1px solid #3e3e3e;
  overflow: hidden;
}

.panel:last-child {
  border-bottom: none;
}
```

**Step 4: Update main CSS to include Tailwind**

Modify `gui/frontend/src/index.css`:
```css
@tailwind base;
@tailwind components;
@tailwind utilities;

body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen,
    Ubuntu, Cantarell, 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}
```

**Step 5: Build and test GUI**

Run: `cd gui && wails dev`
Expected: GUI application launches with working interface

**Step 6: Commit**

```bash
git add gui/
git commit -m "$(cat <<'EOF'
feat: assemble main GUI application

- Create useEmulator hook for state management
- Build main App component with editor and panels
- Integrate RegisterView and MemoryView
- Add execution controls (load, step, run, pause, reset)
- Dark theme with VS Code-inspired styling

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>
EOF
)"
```

---

## Phase 7: Testing and Documentation

### Task 7.1: Add integration tests

**Files:**
- Create: `tests/integration/gui_test.go`
- Create: `gui/frontend/src/test/integration.test.tsx`

**Step 1: Write GUI backend integration test**

Create `tests/integration/gui_test.go`:
```go
package integration_test

import (
	"testing"

	"github.com/lookbusy1344/arm-emulator/parser"
	"github.com/lookbusy1344/arm-emulator/service"
	"github.com/lookbusy1344/arm-emulator/vm"
)

func TestGUIBackendIntegration(t *testing.T) {
	// This test simulates the GUI backend workflow
	machine := vm.NewVM()
	machine.InitializeStack(0x30001000)
	svc := service.NewDebuggerService(machine)

	// Load program
	source := `_start:
		MOV R0, #10
		MOV R1, #32
		ADD R2, R0, R1
		SWI #0`

	p := parser.NewParser(source, "test.s")
	program, err := p.Parse()
	if err != nil {
		t.Fatalf("parse error: %v", err)
	}

	err = svc.LoadProgram(program, 0x8000)
	if err != nil {
		t.Fatalf("LoadProgram error: %v", err)
	}

	// Get initial state
	regs := svc.GetRegisterState()
	if regs.PC != 0x8000 {
		t.Errorf("expected PC=0x8000, got 0x%08X", regs.PC)
	}

	// Execute steps
	for i := 0; i < 3; i++ {
		if err := svc.Step(); err != nil {
			t.Fatalf("step %d error: %v", i, err)
		}
	}

	// Check final state
	regs = svc.GetRegisterState()
	if regs.Registers[0] != 10 {
		t.Errorf("expected R0=10, got %d", regs.Registers[0])
	}
	if regs.Registers[1] != 32 {
		t.Errorf("expected R1=32, got %d", regs.Registers[1])
	}
	if regs.Registers[2] != 42 {
		t.Errorf("expected R2=42, got %d", regs.Registers[2])
	}

	// Test memory access
	mem, err := svc.GetMemory(0x8000, 16)
	if err != nil {
		t.Fatalf("GetMemory error: %v", err)
	}
	if len(mem) != 16 {
		t.Errorf("expected 16 bytes, got %d", len(mem))
	}

	// Test breakpoints
	if err := svc.AddBreakpoint(0x8004); err != nil {
		t.Fatalf("AddBreakpoint error: %v", err)
	}

	bps := svc.GetBreakpoints()
	if len(bps) != 1 {
		t.Errorf("expected 1 breakpoint, got %d", len(bps))
	}
	if bps[0].Address != 0x8004 {
		t.Errorf("expected breakpoint at 0x8004, got 0x%08X", bps[0].Address)
	}

	// Test reset
	if err := svc.Reset(); err != nil {
		t.Fatalf("Reset error: %v", err)
	}

	regs = svc.GetRegisterState()
	if regs.PC != 0x8000 {
		t.Errorf("after reset, expected PC=0x8000, got 0x%08X", regs.PC)
	}
}
```

**Step 2: Run integration test**

Run: `go test ./tests/integration/gui_test.go -v`
Expected: PASS

**Step 3: Write frontend integration test**

Create `gui/frontend/src/test/integration.test.tsx`:
```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { render, screen, waitFor } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import App from '../App'

// Mock Wails API
const mockAPI = {
  LoadProgramFromSource: vi.fn(),
  GetRegisters: vi.fn(),
  Step: vi.fn(),
  Continue: vi.fn(),
  Pause: vi.fn(),
  Reset: vi.fn(),
  AddBreakpoint: vi.fn(),
  RemoveBreakpoint: vi.fn(),
  GetBreakpoints: vi.fn(),
  GetMemory: vi.fn(),
  GetSourceLine: vi.fn(),
  GetSymbols: vi.fn(),
  GetExecutionState: vi.fn(),
  IsRunning: vi.fn(),
}

declare global {
  interface Window {
    go: {
      main: {
        App: typeof mockAPI
      }
    }
  }
}

beforeEach(() => {
  window.go = {
    main: {
      App: mockAPI as any,
    },
  }

  // Default mock responses
  mockAPI.GetRegisters.mockResolvedValue({
    Registers: new Array(16).fill(0),
    CPSR: { N: false, Z: false, C: false, V: false },
    PC: 0x8000,
    Cycles: 0,
  })
  mockAPI.GetExecutionState.mockResolvedValue('idle')
  mockAPI.GetBreakpoints.mockResolvedValue([])
  mockAPI.GetMemory.mockResolvedValue(new Array(256).fill(0))
  mockAPI.LoadProgramFromSource.mockResolvedValue(null)
  mockAPI.Step.mockResolvedValue(null)

  vi.clearAllMocks()
})

describe('App Integration', () => {
  it('should render main interface', async () => {
    render(<App />)

    expect(screen.getByText('ARM Emulator')).toBeInTheDocument()
    expect(screen.getByText('Load')).toBeInTheDocument()
    expect(screen.getByText('Step')).toBeInTheDocument()
    expect(screen.getByText('Run')).toBeInTheDocument()
  })

  it('should load program when Load clicked', async () => {
    const user = userEvent.setup()
    render(<App />)

    const loadButton = screen.getByText('Load')
    await user.click(loadButton)

    await waitFor(() => {
      expect(mockAPI.LoadProgramFromSource).toHaveBeenCalled()
    })
  })

  it('should step execution when Step clicked', async () => {
    const user = userEvent.setup()
    render(<App />)

    const stepButton = screen.getByText('Step')
    await user.click(stepButton)

    await waitFor(() => {
      expect(mockAPI.Step).toHaveBeenCalled()
    })
  })

  it('should display register values', async () => {
    mockAPI.GetRegisters.mockResolvedValue({
      Registers: [42, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      CPSR: { N: false, Z: true, C: false, V: false },
      PC: 0x8004,
      Cycles: 123,
    })

    render(<App />)

    await waitFor(() => {
      expect(screen.getByText(/0x0000002A/)).toBeInTheDocument() // R0 = 42
      expect(screen.getByText(/0x00008004/)).toBeInTheDocument() // PC
      expect(screen.getByText(/123/)).toBeInTheDocument() // Cycles
    })
  })

  it('should show error when operation fails', async () => {
    const user = userEvent.setup()
    mockAPI.LoadProgramFromSource.mockResolvedValue('Parse error at line 1')

    render(<App />)

    const loadButton = screen.getByText('Load')
    await user.click(loadButton)

    await waitFor(() => {
      expect(screen.getByText(/Parse error at line 1/)).toBeInTheDocument()
    })
  })
})
```

**Step 4: Run frontend tests**

Run: `cd gui/frontend && npm test`
Expected: PASS for all tests

**Step 5: Commit**

```bash
git add tests/ gui/frontend/
git commit -m "$(cat <<'EOF'
test: add comprehensive integration tests

- Backend integration test for GUI workflow
- Frontend integration test with mocked Wails API
- Test full user interaction flow
- Verify error handling

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>
EOF
)"
```

---

### Task 7.2: Create GUI documentation

**Files:**
- Create: `docs/GUI.md`
- Modify: `README.md`

**Step 1: Write GUI user documentation**

Create `docs/GUI.md`:
```markdown
# GUI Documentation

## Overview

The ARM Emulator GUI provides a graphical interface for debugging ARM assembly programs. Built with Wails, it combines a Go backend with a React/TypeScript frontend for cross-platform compatibility.

## Features

- **Code Editor**: Write and edit ARM assembly with syntax highlighting
- **Register View**: Real-time display of all 16 registers, PC, and CPSR flags
- **Memory View**: Hex dump and ASCII representation of memory
- **Execution Control**: Step, run, pause, and reset program execution
- **Breakpoints**: Set and manage breakpoints (coming soon)
- **Symbol Resolution**: View and navigate to labels and symbols (coming soon)

## Building

### Prerequisites

- Go 1.25+
- Node.js 18+
- Wails CLI v2.9+

Install Wails:
```bash
go install github.com/wailsapp/wails/v2/cmd/wails@latest
```

### Development Build

```bash
cd gui
wails dev
```

This starts the development server with hot reload.

### Production Build

```bash
cd gui
wails build
```

Binary will be created in `gui/build/bin/`.

## Architecture

### Backend (Go)

The backend uses the existing `service` package to provide a thread-safe interface to the emulator. All business logic resides in Go, with the frontend handling only UI concerns.

Key components:
- `service.DebuggerService`: Core emulator interface
- `gui/app.go`: Wails application bindings
- `gui/main.go`: Application entry point

### Frontend (React/TypeScript)

The frontend is a React application built with TypeScript and Vite.

Key components:
- `App.tsx`: Main application container
- `RegisterView.tsx`: Register and CPSR display
- `MemoryView.tsx`: Memory hex dump
- `useEmulator.ts`: State management hook
- `wails.ts`: Typed API bindings

### Communication

Wails provides bidirectional communication between Go and JavaScript:
- Frontend calls Go methods via `window.go.main.App.*`
- Go can emit events to frontend (for real-time updates)
- All data serialized as JSON

## Testing

### Backend Tests

```bash
# Unit tests
go test ./service/...

# Integration tests
go test ./tests/integration/gui_test.go -v
```

### Frontend Tests

```bash
cd gui/frontend

# Run all tests
npm test

# Run with coverage
npm test -- --coverage

# Run specific test
npm test -- RegisterView
```

## Development Tips

### Hot Reload

In development mode (`wails dev`), both frontend and backend support hot reload. Frontend changes reload instantly, Go changes trigger app restart.

### Debugging

**Frontend:**
- Open DevTools in the app (Cmd+Option+I on macOS)
- Console logs visible in DevTools
- React DevTools extension works

**Backend:**
- Add breakpoints in Go code
- Use `wails dev -debug` for additional logging
- Check terminal output for Go logs

### Adding New Features

1. Add method to `service/debugger_service.go`
2. Add test to `tests/unit/service/`
3. Expose method in `gui/app.go`
4. Add binding in `gui/frontend/src/services/wails.ts`
5. Update `useEmulator` hook if needed
6. Add UI component
7. Write component tests

## Common Issues

**Build fails with "command not found: wails"**
- Ensure `~/go/bin` is in your PATH
- Run: `export PATH=$PATH:~/go/bin`

**Frontend doesn't update**
- Clear Vite cache: `rm -rf gui/frontend/.vite`
- Reinstall deps: `cd gui/frontend && npm ci`

**"Cannot read property 'go' of undefined"**
- Wails bindings not injected (only available in built app, not in browser)
- Use mock for testing: see `wails.test.ts`

## Performance

The GUI is designed for smooth performance even with large programs:

- Register updates are throttled during continuous execution
- Memory view uses virtual scrolling (planned)
- Execution runs on separate goroutine to avoid blocking UI
- Frontend uses React.memo and useMemo for expensive renders

## Accessibility

- Keyboard navigation supported throughout
- ARIA labels on all interactive elements
- High contrast color scheme
- Screen reader compatible (via semantic HTML)
```

**Step 2: Update main README with GUI instructions**

Add to `README.md` (after TUI section):
```markdown
### GUI Mode (Graphical Interface)

Run programs in GUI mode with code editor, register view, and memory inspector:

```bash
cd gui
wails dev  # Development mode
```

Or build for production:

```bash
cd gui
wails build
./build/bin/arm-emulator
```

See [docs/GUI.md](docs/GUI.md) for detailed GUI documentation.
```

**Step 3: Commit**

```bash
git add docs/ README.md
git commit -m "$(cat <<'EOF'
docs: add comprehensive GUI documentation

- Create GUI.md with architecture overview
- Document building and testing procedures
- Add development tips and troubleshooting
- Update main README with GUI instructions

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>
EOF
)"
```

---

## Phase 8: Final Testing and Polish

### Task 8.1: Run full test suite

**Files:**
- None (verification only)

**Step 1: Run all Go tests**

Run: `go clean -testcache && go test ./... -v`
Expected: PASS for all tests (1024+ tests)

**Step 2: Run GUI backend tests**

Run: `cd gui && go test -v`
Expected: PASS

**Step 3: Run frontend tests**

Run: `cd gui/frontend && npm test -- --run`
Expected: PASS for all tests

**Step 4: Run frontend coverage**

Run: `cd gui/frontend && npm test -- --coverage`
Expected: >80% coverage for components and hooks

**Step 5: Build and verify GUI**

Run: `cd gui && wails build`
Expected: Successful build, binary created in `build/bin/`

Run: `cd gui/build/bin && ./gui`
Expected: GUI launches successfully

**Step 6: Verify no step was skipped**

Confirm:
- âœ“ Service layer created and tested
- âœ“ Wails backend integrated
- âœ“ TypeScript bindings created
- âœ“ React components built and tested
- âœ“ Main app assembled
- âœ“ Integration tests written
- âœ“ Documentation complete

---

### Task 8.2: Update project documentation

**Files:**
- Modify: `PROGRESS.md`
- Modify: `CHANGELOG.md` (if exists)

**Step 1: Update PROGRESS.md**

Add to `PROGRESS.md`:
```markdown
## Phase 12: GUI Implementation (Oct 2025) - COMPLETE âœ…

### Wails-Based Cross-Platform GUI

**Architecture:**
- Shared service layer (`service/` package) used by TUI, CLI, and GUI
- Wails v2.9+ backend with Go bindings
- React 18 + TypeScript 5 frontend
- Thread-safe emulator interface
- Maximum code reuse between interfaces

**Frontend Stack:**
- React 18 with TypeScript 5
- Vite for build tooling
- Tailwind CSS for styling
- Vitest + React Testing Library for testing
- >80% test coverage

**Features Implemented:**
- Code editor with ARM assembly support
- Register view with real-time updates and change highlighting
- Memory viewer with hex dump and ASCII representation
- Execution controls (load, step, run, pause, reset)
- Error handling and display
- Dark theme inspired by VS Code

**Testing:**
- 100% of components tested
- Integration tests for backend workflow
- Frontend integration tests with mocked API
- All existing tests still passing (1024+ tests)

**Documentation:**
- Complete GUI user guide (docs/GUI.md)
- Architecture documentation
- Development and troubleshooting tips
- README updated with GUI instructions
```

**Step 2: Commit documentation updates**

```bash
git add PROGRESS.md
git commit -m "$(cat <<'EOF'
docs: document Phase 12 GUI implementation completion

- Update PROGRESS.md with GUI features
- Note architecture and testing coverage
- Mark phase as complete

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>
EOF
)"
```

---

## Summary

This plan implements a cross-platform GUI using Wails with React/TypeScript, achieving:

1. **Maximum Code Reuse**: Shared service layer used by TUI, CLI, and GUI
2. **Modern Stack**: React 18, TypeScript 5, Vite, Tailwind CSS
3. **Comprehensive Testing**: >80% frontend coverage, full backend coverage
4. **Type Safety**: End-to-end TypeScript with Go struct bindings
5. **Developer Experience**: Hot reload, component tests, clear documentation

**Total Effort Estimate**: 8 phases, ~25 tasks, 3-5 days for experienced developer

**Key Benefits Over Alternatives**:
- React: Best testing ecosystem (critical requirement met)
- Wails: Native performance, small bundle size
- Shared service: Zero duplication with TUI
- TypeScript: Compile-time safety for complex state

**Next Steps After Implementation**:
- Add breakpoint UI and management
- Implement source code view with syntax highlighting
- Add symbol table browser
- Implement watch expressions
- Add memory region annotations
- Performance profiling view
