# ARM Emulator - a vibe coding project

[![CI](https://github.com/lookbusy1344/arm_emulator/actions/workflows/ci.yml/badge.svg)](https://github.com/lookbusy1344/arm_emulator/actions/workflows/ci.yml)

This is an example of using vibe coding to re-create my first commercial project, from 1992, which implemented an ARM2 emulator. The original code was written in Turbo Pascal for 16-bit MS-DOS and is completely lost.

Here I am attempting to use Claude Code to broadly recreate the emulator as a cross-platform Go project, with a simple TUI debugger. Claude was given a one-paragraph prompt and essentially left to its own devices, with only gentle high level steering.

After the TUI interface, I went on to make a cross-platform GUI using Wails. While this works, I was dissatisfied with the webview interface, so **the Wails GUI is now deprecated**. The current GUI is a **native Swift app for macOS** that provides a superior native experience, calling into the Go VM using a REST API.

Perhaps later I will write a Windows GUI using the same backend, using WinUI or WPF.

## Security

This project was vibe-coded. See [docs/SECURITY.md](docs/SECURITY.md) for a comprehensive security audit generated by Copilot.

## Background

ARM2 is the earliest commercial precursor to the AARCH64 architecture we all use in our smartphones, Macs and low-power Windows laptops. It started life in the mid-1980’s at the UK’s Acorn Computers.

The ARM1 (Acorn RISC Machine 1) was Acorn Computers' first microprocessor design. The ARM1 was the initial result of the Advanced Research and Development division Acorn Computers formed in order to advance the development of their own RISC processor. Design started in 1983, and when it was finished in 1985 the ARM1 was the simplest RISC processor produced worldwide.

Introduced in 1986, the ARM2 was capable of exceeding 10 MIPS when not bottlenecked by memory with an average of around 6 MIPS. Unlike the ARM1 which was predominantly a research project, the ARM2 became the first commercially successful ARM microprocessor.

The Acorn Archimedes family of personal computers was built using the ARM2 along with a number of fully custom support chips that were also designed by Acorn Computers.

https://en.wikichip.org/wiki/acorn/microarchitectures/arm1

## Vibe Coded

This is a vibe-coded project. Details of the initial prompt and development process followed in the first few weeks are documented in [Vibe_coding.md](Vibe_coding.md).

## Documentation

### Project Documentation
- [SPECIFICATION.md](SPECIFICATION.md) - Detailed specification for the ARM2 emulator
- [docs/IMPLEMENTATION_PLAN.md](docs/IMPLEMENTATION_PLAN.md) - Implementation roadmap and plan
- [PROGRESS.md](PROGRESS.md) - Development progress and completed phases
- **[docs/SECURITY.md](docs/SECURITY.md) - Comprehensive security audit and anti-virus false positive explanation**

### User Documentation
- [docs/installation.md](docs/installation.md) - Installation guide and setup
- [docs/TUTORIAL.md](docs/TUTORIAL.md) - Step-by-step tutorial for learning ARM2 assembly
- [docs/INSTRUCTIONS.md](docs/INSTRUCTIONS.md) - ARM2 instruction set reference (CPU instructions and syscalls)
- [docs/ASSEMBLER.md](docs/ASSEMBLER.md) - Assembler directives and syntax (.text, .data, .word, .ltorg, etc.)
- [docs/REFERENCE.md](docs/REFERENCE.md) - Programming reference (condition codes, addressing modes, shifts)
- [docs/assembly_reference.md](docs/assembly_reference.md) - ARM2 assembly language reference (directives, syntax)
- [examples/README.md](examples/README.md) - Example programs and usage instructions (49 programs)
- [docs/debugger_reference.md](docs/debugger_reference.md) - Complete debugger command reference and guide
- [docs/debugging_tutorial.md](docs/debugging_tutorial.md) - Hands-on debugging tutorials with examples
- [docs/FAQ.md](docs/FAQ.md) - Frequently asked questions and troubleshooting

### Developer Documentation
- [API.md](API.md) - Complete HTTP REST API and WebSocket reference
- [openapi.yaml](openapi.yaml) - OpenAPI 3.0 specification (machine-readable)
- [docs/SWIFT_APP.md](docs/SWIFT_APP.md) - Swift native macOS app guide
- [docs/architecture.md](docs/architecture.md) - System architecture and design
- [docs/ltorg_implementation.md](docs/ltorg_implementation.md) - Literal pool implementation details

## Features

- **Complete ARM2 instruction set implementation** with 1,024 passing tests (100% pass rate, 75% code coverage)
  - All 16 data processing instructions (AND, EOR, SUB, RSB, ADD, ADC, SBC, RSC, TST, TEQ, CMP, CMN, ORR, MOV, BIC, MVN)
  - All memory operations (LDR/STR/LDRB/STRB/LDM/STM + halfword extensions)
  - All branch instructions (B/BL/BX)
  - Multiply instructions (MUL/MLA)
  - All ARM2 addressing modes (immediate, register, shifted, pre/post-indexed)
  - Software interrupts with 35+ syscalls (console I/O, file operations, memory management, system information, debugging support)
- Assembly parser for ARM assembly programs with macros and preprocessor
- **Dynamic literal pool sizing**: Smart allocation based on actual literal usage, not fixed estimates
  - Counts LDR pseudo-instructions per `.ltorg` directive
  - Adjusts pool addresses for optimal space utilization
  - Validation warnings for pools exceeding capacity
  - Support for 20+ literals per pool (tested up to 33)
- Machine code encoder/decoder for binary ARM instruction formats
- Interactive debugger with TUI (Text User Interface)
- Virtual machine execution environment
- Cross-platform configuration management (TOML)
- Execution and memory tracing with filtering
- Performance statistics (JSON/CSV/HTML export)
- **Diagnostic modes: code coverage, stack trace, flag trace, register access pattern analysis**
- Development tools (linter, formatter, cross-reference generator)

## Prerequisites

- Go 1.25 or higher (only required if building from source)
- Supported platforms: macOS, Linux, Windows

## Installation

### Option 1: Download Pre-built Binaries (Recommended)

Pre-built binaries are available for download from the [Releases](https://github.com/lookbusy1344/arm_emulator/releases) page.

**Available platforms:**
- **Linux (64-bit):** `arm-emulator-linux-amd64`
- **macOS (Apple Silicon):** `arm-emulator-macos-arm64`
- **Windows:** `arm-emulator-win-amd64.exe` (AMD64/x64) and `arm-emulator-win-arm64.exe` (ARM64)

**To install:**
1. Visit the [Releases](https://github.com/lookbusy1344/arm_emulator/releases) page
2. Download the binary for your platform
3. On Linux/macOS, make it executable: `chmod +x arm-emulator-*`
4. Optionally verify the download using the provided SHA256 checksums

**Security Note for Windows Users:**
Some anti-virus software may flag the Windows binary due to heuristic detection of emulator behavior patterns (memory management, file I/O). This is a **false positive** - the software is safe. See [docs/SECURITY.md](docs/SECURITY.md) for a complete security audit. You may need to whitelist the application or build from source.

### Option 2: Build from Source

Clone the repository and build the project:

```bash
git clone <repository-url>
cd arm_emulator
go build -o arm-emulator
```

## Usage

### Running Assembly Programs

Run an ARM assembly program directly:

```bash
./arm-emulator program.s
```

The emulator will execute the program starting from `_start` (or `main` if `_start` is not found). The program runs until it encounters a `SWI #0x00` (exit) instruction or an error occurs.

### Using the Debugger

The emulator includes a powerful debugger with both command-line and TUI (Text User Interface) modes:

```bash
# Command-line debugger mode
./arm-emulator --debug program.s

# TUI mode with visual panels for source, registers, memory, etc.
./arm-emulator --tui program.s
```

**Quick debugger commands:**
- `run` (r) - Start/restart program execution
- `step` (s) - Execute one instruction (step into)
- `next` (n) - Execute one instruction (step over)
- `continue` (c) - Continue until breakpoint or exit
- `break <location>` (b) - Set breakpoint at label or address
- `print <expr>` (p) - Evaluate expression (registers, memory, etc.)
- `info registers` (i r) - Show all registers
- `help` - Show all available commands

**TUI keyboard shortcuts:**
- `F5` - Continue execution
- `F9` - Toggle breakpoint at current line
- `F10` - Step over
- `F11` - Step into
- `Ctrl+L` - Refresh display
- `Tab` - Switch between panels

**TUI visual features:**
- **Register highlighting** - Changed registers shown in green
- **Memory write highlighting** - Written memory bytes shown in green (auto-scrolls to written address)
- **Stack highlighting** - PUSH/POP operations highlighted in green
- **Symbol-aware display** - Function/label names shown instead of raw addresses
- **Source view** - Shows current line with `>` indicator, handles labels and comments properly
- **Multi-panel layout** - Source, Registers, Memory, Stack, Breakpoints, Watchpoints, Console

For complete debugger documentation including conditional breakpoints, watchpoints, memory examination, and expression syntax, see [docs/debugger_reference.md](docs/debugger_reference.md).

### GUI Mode (Graphical Interface)

**Two GUI options available:**

#### Option 1: Swift Native macOS App (Recommended)

A native macOS app built with SwiftUI that connects to the Go backend API:

**Prerequisites:**
```bash
# Install required tools
brew install xcodegen swiftlint swiftformat xcbeautify
```

**Generate and open Xcode project:**
```bash
cd swift-gui
xcodegen generate      # Generate Xcode project from project.yml
open ARMEmulator.xcodeproj
```

**Run the app:**
```bash
# Open and run from Xcode (backend starts automatically)
cd swift-gui
open ARMEmulator.xcodeproj
# Press Cmd+R to build and run
```

The Swift app automatically manages the Go backend lifecycle - it will find, start, and monitor the backend process. No manual backend startup required.

**Build from command line:**
```bash
cd swift-gui
xcodebuild -project ARMEmulator.xcodeproj -scheme ARMEmulator build | xcbeautify
```

Built app location: `~/Library/Developer/Xcode/DerivedData/ARMEmulator-*/Build/Products/Debug/ARMEmulator.app`

To run the built app:
```bash
# Find and open the built app
find ~/Library/Developer/Xcode/DerivedData -name "ARMEmulator.app" -type d -exec open {} \; -quit
```

**Features:**
- Native macOS SwiftUI interface
- Real-time register updates via WebSocket
- Code editor with syntax awareness
- Console output view
- Full MVVM architecture

**Important notes:**
- The Xcode project is generated from `project.yml` - run `xcodegen generate` after modifying it
- Requires the Go API backend running on port 8080
- Full Xcode IDE support (debugging, previews, breakpoints)
- Code quality enforced with SwiftLint and SwiftFormat (0 violations policy)

**Documentation:**
- [docs/SWIFT_APP.md](docs/SWIFT_APP.md) - Complete Swift app guide (architecture, building, development)
- [SWIFT_GUI_PLANNING.md](SWIFT_GUI_PLANNING.md) - Implementation roadmap and technical planning
- [docs/SWIFT_CLI_AUTOMATION.md](docs/SWIFT_CLI_AUTOMATION.md) - General Swift CLI development guide
- [API.md](API.md) - REST API and WebSocket reference
- [openapi.yaml](openapi.yaml) - OpenAPI 3.0 specification

#### Option 2: Wails Cross-Platform GUI (⚠️ Deprecated)

> **Note:** The Wails GUI is deprecated in favor of the native Swift app. It remains available for reference and cross-platform testing, but is no longer actively developed. See [Wails.md](Wails.md) for complete Wails documentation.

Run programs in GUI mode with code editor, register view, and memory inspector:

```bash
cd gui
wails dev  # Development mode
```

Or build for production:

```bash
cd gui
wails build
./build/bin/arm-emulator
```

**Documentation:**
- [Wails.md](Wails.md) - Quick reference and development guide
- [docs/GUI.md](docs/GUI.md) - Complete architecture and implementation details
- [gui/frontend/e2e/README.md](gui/frontend/e2e/README.md) - E2E testing guide

**E2E Testing:**

End-to-end tests for the GUI require the Wails backend running in a separate terminal:

```bash
# Terminal 1: Start Wails backend
cd gui
wails dev -nocolour

# Terminal 2: Run E2E tests (after backend is ready)
cd gui/frontend
npm run test:e2e -- --project=chromium
```

See [gui/frontend/e2e/README.md](gui/frontend/e2e/README.md) for complete testing documentation.

### Symbol Table Dump

Inspect the parsed symbols from your assembly program:

```bash
# Dump symbol table to stdout
./arm-emulator --dump-symbols program.s

# Save symbol table to a file
./arm-emulator --dump-symbols --symbols-file symbols.txt program.s
```

The symbol dump displays all labels, constants, and variables with their addresses, types, and definition status. This is useful for understanding program layout and debugging symbol resolution issues.

### Performance Analysis

The emulator includes built-in tracing and statistics capabilities:

```bash
# Enable execution tracing
./arm-emulator --trace --trace-file trace.txt program.s

# Enable memory access tracing
./arm-emulator --mem-trace --mem-trace-file mem_trace.txt program.s

# Generate performance statistics
./arm-emulator --stats --stats-file stats.html --stats-format html program.s
```

**Performance features:**
- Execution trace with register changes and timing
- Memory access tracking (reads/writes)
- Instruction frequency analysis
- Branch statistics and prediction
- Function call profiling
- Hot path analysis
- Export to JSON, CSV, or HTML formats

### Diagnostic Modes

Advanced debugging tools to help identify and fix issues:

```bash
# Code coverage - track which instructions were executed
./arm-emulator --coverage program.s

# Stack trace - monitor stack operations and detect overflow/underflow
./arm-emulator --stack-trace program.s

# Flag trace - track CPSR flag changes for debugging conditional logic
./arm-emulator --flag-trace program.s

# Register trace - analyze register access patterns
./arm-emulator --register-trace program.s

# Combine multiple diagnostic modes with verbose output
./arm-emulator --coverage --stack-trace --flag-trace --register-trace --verbose program.s
```

**Diagnostic features:**

**Code Coverage:**
- Tracks executed vs unexecuted instructions with symbol names
- Reports coverage percentage
- Shows execution counts for each address
- Records first and last execution cycle
- Identifies dead code and untested paths
- Symbol-aware output (e.g., `0x00008000: executed 1 times [main]`)

**Stack Trace:**
- Monitors all stack operations (PUSH, POP, SP modifications)
- Tracks stack depth and maximum usage
- **Detects and warns on stack overflow/underflow**
- Detailed trace with addresses and values
- Symbol-aware output showing function names (e.g., `[000005] nested_call : MOVE SP: 0x00050000 -> 0x0004FFEC`)
- Helps identify stack-related bugs

**Flag Trace:**
- Tracks CPSR flag changes (N, Z, C, V)
- Only records actual changes for efficiency
- Shows before/after states with highlights
- Statistics on flag change frequency
- Symbol-aware output showing labels (e.g., `[000012] loop : 0xE355000C ---- -> N*---`)
- Helps debug conditional logic issues

**Register Access Pattern Analysis:**
- Tracks read/write patterns for all registers
- Identifies "hot" registers (most frequently accessed)
- Detects unused registers
- Flags read-before-write issues (potential uninitialized use)
- Shows unique value counts and access sequences
- Helps optimize register allocation and find bugs

All diagnostic modes support both text and JSON output formats:
```bash
# JSON output for programmatic analysis
./arm-emulator --coverage --coverage-format json program.s
./arm-emulator --stack-trace --stack-trace-format json program.s
./arm-emulator --flag-trace --flag-trace-format json program.s
./arm-emulator --register-trace --register-trace-format json program.s
```

### Example Programs

The `examples/` directory contains 49 sample ARM assembly programs that demonstrate various features (100% working):

**Basic Examples:**
- **hello.s** - Hello World program
- **arithmetic.s** - Basic arithmetic operations

**Algorithm Examples:**
- **fibonacci.s** - Fibonacci sequence generator
- **factorial.s** - Recursive factorial calculator
- **bubble_sort.s** - Bubble sort algorithm
- **binary_search.s** - Binary search implementation
- **gcd.s** - Greatest common divisor

**Data Structure Examples:**
- **arrays.s** - Array operations
- **linked_list.s** - Linked list implementation
- **stack.s** - Stack implementation
- **strings.s** - String manipulation

**Advanced Examples:**
- **functions.s** - Function calling conventions
- **conditionals.s** - If/else, switch/case patterns
- **loops.s** - For, while, do-while loops
- **addressing_modes.s** - ARM2 addressing modes demonstration
- **add_128bit.s** - 128-bit integer addition with carry propagation

And more! See [examples/README.md](examples/README.md) for detailed descriptions and usage instructions.

## Development

### Building

```bash
go build -o arm-emulator
```

### Formatting

```bash
go fmt ./...
```

### Testing

```bash
go clean -testcache
go test ./...
```

## Update dependencies

```bash
go get -u ./...
go mod tidy
go mod verify
```

### Release Builds

Create optimized release builds for distribution:

**Using Make (recommended):**
```bash
make build
```

This automatically embeds version information from git tags:
- Version number from git tag (e.g., `v1.0.1`)
- Git commit hash
- Build timestamp

**Manual build with version info:**
```bash
VERSION=$(git describe --tags --always --dirty)
COMMIT=$(git rev-parse --short HEAD)
DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
go build -ldflags "-X main.Version=$VERSION -X main.Commit=$COMMIT -X main.Date=$DATE" -o arm-emulator
```

**Local optimized build:**
```bash
go build -ldflags="-s -w" -o arm-emulator
```

The `-ldflags="-s -w"` flags strip symbol tables and debug information, producing smaller, faster-loading binaries suitable for distribution (~30-40% size reduction).

**Automated release builds:**

The project includes automated GitHub Actions workflows that create optimized release builds for multiple platforms:

```bash
git tag v1.0.0
git push origin v1.0.0
```

This triggers the `Build Release` workflow which:
- Builds optimized binaries for **linux-amd64**, **macos-arm64**, **windows-amd64**, and **windows-arm64**
- Generates SHA256 checksums for each binary
- Creates a GitHub Release with pre-built binaries, individual checksums, and a combined SHA256SUMS file
- Users can download platform-specific binaries directly from the [Releases](https://github.com/lookbusy1344/arm_emulator/releases) page

**Verifying downloads:**

To verify the integrity of a downloaded binary, use the SHA256 checksums provided in the release:

```bash
# On Linux/macOS - verify using the combined SHA256SUMS file
sha256sum -c SHA256SUMS --ignore-missing

# On Linux/macOS - verify a specific binary
sha256sum arm-emulator-linux-amd64
# Compare the output with the checksum in the .sha256 file

# On Windows (PowerShell)
Get-FileHash arm-emulator-windows-amd64.exe -Algorithm SHA256
# Compare the output with the checksum in the .sha256 file
```

Each release includes:
- Individual `.sha256` files for each binary (e.g., `arm-emulator-linux-amd64.sha256`)
- A combined `SHA256SUMS` file containing all checksums for easy verification

## Project Structure

```
.
├── main.go              # Entry point and CLI
├── vm/                  # Virtual machine implementation
├── parser/              # Assembly parser with preprocessor
├── instructions/        # Instruction implementations
├── encoder/             # Machine code encoder/decoder
├── debugger/            # Debugging utilities with TUI
├── config/              # Cross-platform configuration
├── tools/               # Development tools (lint, format, xref)
├── api/                 # HTTP REST API backend for GUIs
├── service/             # Service layer for API/GUI integration
├── swift-gui/           # Swift native macOS app (SwiftUI + MVVM) - Primary GUI
├── gui/                 # Wails cross-platform GUI (DEPRECATED)
├── tests/               # Test files (1,024 tests, 100% passing, 75% coverage)
├── examples/            # Example ARM assembly programs (49 programs)
└── docs/                # User and developer documentation
```

## Instruction Set Completeness

This emulator provides **complete ARM2 instruction set coverage** as implemented in the original 1986 Acorn ARM2 processor. All core ARM2 instructions and addressing modes are fully functional and tested.

**Beyond ARM2 - Additional instructions implemented:**
- **Long multiply instructions (UMULL/UMLAL/SMULL/SMLAL)** - introduced in ARMv3M (ARM6), fully implemented with 64-bit results
- **PSR transfer instructions (MRS/MSR)** - introduced in ARMv3, implemented for CPSR flag manipulation

**What's NOT implemented:**
- Atomic swap instructions (SWP/SWPB) - introduced in ARMv2a (ARM3), not original ARM2
- Coprocessor instructions (CDP/LDC/STC/MCR/MRC) - optional in ARMv2, rarely used

## Security

This project has undergone a comprehensive security audit. Key findings:

- ✅ **NO network connectivity** - No code to connect to remote servers
- ✅ **NO downloads** - No capability to download external content
- ✅ **NO system file modifications** - Only operates on user-specified files
- ✅ **Legitimate dependencies** - All third-party libraries are well-known and safe
- ✅ **Open source** - Full source code available for inspection

**Anti-Virus False Positives:** Some anti-virus software may flag the Windows binary as `Program:Win32/Wacapew.C!ml` due to heuristic detection of legitimate emulator behaviors (memory management, file I/O, code execution patterns). This is a **false positive** - the software contains no malicious code.

### ⚠️ Important: Filesystem Access

**The ARM emulator restricts guest program file access to a specified directory for security.**

By default, file operations are restricted to the current working directory. Use the `-fsroot` flag to specify a different allowed directory:

```bash
# Restrict to current directory (default)
./arm-emulator program.s

# Restrict to specific sandbox directory
./arm-emulator -fsroot /tmp/sandbox program.s
```

**Security guarantees:**
- ✅ Guest programs can only access files within the specified root directory
- ✅ Path traversal attempts (using `..`) are blocked and halt the VM
- ✅ Symlink escapes outside the root are blocked and halt the VM
- ✅ Absolute paths are treated as relative to the filesystem root
- ✅ Filesystem sandboxing is always enforced - no unrestricted access mode

**Still treat assembly code with caution.** Within the allowed directory, programs can:
- Read, write, or delete any accessible file
- Create new files
- Consume system resources (memory, disk space, CPU up to configured limits)

**Recommendation:** Create a dedicated sandbox directory with only necessary files for maximum isolation.

For a detailed security analysis, see **[docs/SECURITY.md](docs/SECURITY.md)**.

## License

MIT License. See `LICENSE` file for details.
